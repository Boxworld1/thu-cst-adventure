## 3-5 Prefix  解题报告 ##

#### 容逸朗 2020010869 ####

### 1  解法 ###

本题需要找出所有前缀在字串出现的次数总和，因此可以利用经典的 KMP 算法。

#### 1.1 思考

先考察一个简单的例子：

```
patten:  aabaab
next:   -1010123
dp:      0121232
```

字串 `aabaab` 及对应的 next 表如上，next 表表示不包括当前字符的最长相同前后缀的长度，dp 表表示不包括当前字符的前缀字串符合条件的字符串总数。

从 next 表和 dp 表的规律可以发现，对于每一个 `i` ，若 `nxt[i] = j` ，则 `dp[i] = dp[j] + 1`。其原因在于 `[0, j)` 位置合乎条件的字符串总数为 `dp[j]` 。（若 `j` 为 `0`，结论亦然，此時 `dp[i] = 1` 对应着 `[0,i)` 这一前缀）

对于 `[0, i)` ，这段区间以 `p[i - 1]` 为结尾的字符串会比 `[0, j)` 多出了一个，也就是 `[0, i)` 。显然 `[j, i - 1)` 内不会出现 `p[i - 1]` 的同一个字符，否则 `p[i - 1]` 的 next 表应该指向 `[j, i - 1)` 内与之相同的元素，矛盾！

由此可见，我们只需要在建立 next 表的同时建立 dp 表即可。

#### 1.2 实现

和一般 KMP 实现方式相同，但是在匹配成功的情况下加入了 dp 表的更新语句：

```c++
while (j < len) {
    if (t < 0 || str[j] == str[t]) { // success
        nxt[++j] = ++t; // update next
        dp[j] = dp[t] + 1;
        ans += dp[j];
    } else {
        t = nxt[t]; // fail, check next
    }
}
```

#### 1.3 分析

算法的时间复杂度为 $O(n)$，这是因为每次操作都会使 `j-t` 和 `j` 中的至少一个数增大，由于 `j - t <= j ` 以及 `j <= len` ，故算法最多执行 $O(2n)$ 次，所以算法的时间复杂度为 $O(n)$ 。

空间复杂度为 $O(n)$ 。

