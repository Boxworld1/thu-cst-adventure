## 2-2 Not Found  解题报告 ##

#### 容逸朗 2020010869 ####

### 1  解法 ###

题目需要找出一个01串中未曾出现过的最短01串。

#### 1.1 暴力枚举

一个直观的想法是暴力枚举可能的答案：不难想到一个 $O(n^2)$ 的算法，该算法遍历了所有可能组成的组合，此时通过排序便可得到最终答案，但这个算法显然会超时，而且题目给出的空间大小并不足以存储如此大的数据。

#### 1.2 好一点的枚举算法

虽然这个算法不能解决本题，但仍然给出了一个很好的思路：枚举。不妨思考枚举时的字串长度，由抽屜原理知，字串的长度不可能比 $\log_2 n$ 长，对于长为 $\log_ 2n$ 的字串最多有 $2^{\log_2n} =n$ 种，但长度为 $n$ 的字串最多只能出现 $n-\log_2n+1$ 个不同的长度为 $\log_2n$ 的字串，故长度不能比 $\log_2n$ 更长。

由此，我们只需要记录长度小于 $log_2n = 24$ 的字串，此时算法复杂度为 $O(n\log n)$ ，仍然不能解决此题。

#### 1.3 动态规划

从 `1.2` 中不难想到一个更优的 $O(n)$ 算法，即读入时只记录长度为 `24` 的字串，然后 dp 从后至前查找能表示的字串。对于任意一个01串 $a$ ，若 $0a$ , $1a$ , $a0$ , $a1$ 中的一个曾经出现过，那么显然 $a$ 也出现过，因此由长至短遍历可能的字串就能得到一个在原字串中出现过的字串表。

```c++
for (int i = hi; i > 1; i--) {
    int base = int(log2(i));
    if (test(i << 1) || test((i << 1) | 1) || 
    		test((2 << base) ^ i) || test((3 << base) ^ i)) {
        set(i);
    }
}
```

最后按字典序的大小顺序查找答案便能通过此题。

初始读入数据时间复杂度为 $O(n)$ ，动态规划查找了长度为 `1` 至 `log2(n) - 1 = 23` 的串，这些串共有 $1+2+4+⋯+2^{\log_2n - 1} = 2^{\log_2n}-1 = n - 1$ 个，共查询了 $4\times (n-1) = 4n- 4$ 次，故 dp 的時间复杂度也为 $O(n)$ ，最后遍历答案的最坏情况也为 $O(n)$ 。

因此算法整体时间复杂度为 $O(n)$ ，空间复杂度为 $O(n)$。

#### 1.4 空间限制

注意到题目可用的空间大小为 `6MB` ，这个大小的空间可以储放长度为 `6000000` 的 `char` 数组，为了节省空间，我们需要即时处理读入的数据，这样读入的空间仅为 $O(1)$ ，剩下的空间可以用于纪录答案。由于答案的最大长度小于 $\log n=24$ ，故可能的答案会有 $2^{25}$ 种，若使用 `bitset` 存储数据，则需要长度为 $2^{25}\div8=4194304$ 的 `char` 数组，恰好满足条件。

### 2  遇到的问题

#### 2.1 字串、数字转换

对于任意一个01串，我们都可以找到一个数字与其对应，我最初使用的方法是直接转换，也就是 $10=3$ 、 $010 = 3$  等，不难发现这种转换不能解决前缀为 `0` 的情况。一种解决方法是在字串前加上 `1` 再转换，为了节省时间，我使用了位运算来得到结果。

#### 2.2 长度小于N的串

以上的讨论都是建基于字串长度大于等于 N 而言的，因此需要针对长度小于N的串作讨论，并制作不同的 `mask` 来简化运算。
