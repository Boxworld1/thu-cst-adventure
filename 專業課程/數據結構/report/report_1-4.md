## 1-4 Risk  解题报告 ##

#### 容逸朗 2020010869 ####

### 1  解法 ###

由于 $i-m_i$ 是一个单调不下降数列，因此我们只需要维护一个大根堆，其中大根堆的元素包含了每天的确诊病例数和日期。如果要寻找第 $i$ 天前 $m_i$ 天的最大值，可以先把堆顶不在范围 $[i-m_i, i)$ 内的值 pop 出去，然后剩下的堆顶元素就是第 $i$ 天前 $m_i$ 天的最大值（此元素必定在范围 $[i-m_i, i)$ 内）。

若把这些数字按大小排序，则每次询问都需要 $O(\log n)$ 的时间。但我们完全可以用前缀和来解决问题，不妨记 $ans[i]$ 为最大值小于 $i$ 的日数，那么 $ans[p]$ 就是最大值小于 $p$ 的日数，而 $ans[q]-ans[p]$ 则是最大值在 $[p, q)$ 之间的日数。因此对于每次询问，我们只需用 $O(1)$ 的时间便可得到结果。

需要注意的是，题目中给出的 $m_i,p_i,q_i$ 远比他们的最大可能值 $2*10^6$ 大，因此需要特別判断，避免数组越界。

时间复杂度为 $O(n\log n)$ ，空间复杂度为 $O(n)$。
本地测试中，对于规模 $n=10^6$ 和 $m=10^5$ 的数据，程序需运行 $340ms$ 。

### 2  具体实现

由于我们需要的大根堆是没有初始值的，因此只需要有 push 和 pop 两个函数就可以了。

#### 2.1 push 函数

对于 push 函数，我们首先把要插入的数放到堆的最后，然后通过和父结点的比较，若插入值比父结点大，则上浮，重复操作直至父结点的值比要插入的数值为大，插入结束。

#### 2.2 pop 函数

对于 pop 函数，我们首先把堆的最后一个元素移到堆顶，然后通过和左右子结点的比较，此时若子结点数值比另一子结点（若存在）和父结点大，则与父结点交換，重复此操作，直至父结点的值比子结点的数值为大，插入结束。

### 3  遇到的问题 - 十年 OI 一场空，不开 long long 见祖宗

在提交了第一次九成测后，喜提 85 分。

系统提示是 SIGSEGV，于是重新看了一遍数据范围。好家伙，$m_i$ 竟然达到了神奇的 $2^{32}$ ，由于读入 $m_i$ 时没开 long long，所以就爆了。

改了个 long long 交上去就过了。

