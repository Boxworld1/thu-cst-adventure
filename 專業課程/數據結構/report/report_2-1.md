## 2-1 Build  解题报告 ##

#### 容逸朗 2020010869 ####

### 1  解法 ###

本题要求模拟多叉树的移动，并求出移动过程中不同节点的高度和规模。此题直接模拟计算即可，题目可以分为以下几个任务：建树、查找节点、移除子树、插入子树。

#### 1.1 建树

首先把多叉树按二叉树的形式存储，对于每一个结点，应当记录如下信息：

````c++
struct Node {
    int parent = 0, lc = 0, rc = 0; // parent, first child, next sibling
    int size = 0, height = -1; // tree size, tree height
    int sibSize = 0, sibHeight = -1; // sibling size and max height
} a[N];
````

父节点 `parent` 、第一个子节点（存放于左子 `lc` ），下一个兄弟节点（存放于右子 `rc` ），节点规模、高度以及后缀弟节点的总规模和最大高度。（注意空树的规模为 `0` ，高度为 `-1` ）

由于题目直接给出每个节点的子节点，因此可以直接建树，但需要将第一个结点放于根节点的左子，其他节点则依次存放于兄节点的右子中，读入同时需要将结点高度和规模设为 `0` 和 `1` 。

树建好后，需要更新节点上的信息（节点规模、高度以及后缀弟节点的总规模和最大高度），这里先遍历右子树再遍历左子树。

1. 当右子树遍历完成后，可以更新节点的后缀弟节点的总规模和最大高度。
2. 当左子树遍历完成后，就可以直接计算此节点的高度和规模。

建树和更新节点信息的时间复杂度为 $O(n)$ ，空间复杂度也为 $O(n)$ 。

#### 1.2 查找节点

题目给出节点的路径，故只需要按照路径遍历即可。这里使用了“栈”记录走过的节点，原因在于后续更新节点时会按遍历顺序由后到前更新。

由于题目给出的路径不一定能走到合法的节点，故在每一步查找时需要记下最后一个合法的节点，避免非法节点复盖了合法的节点。

#### 1.3 移除子树

移除子树可以根据子树根节点（遍历时）的上一个节点分为两种不同的情况：

1. 上一个节点为被移除节点的父节点

   ```c++
   a[lst].lc = a[rt].rc; // 连接到被移除节点的右子，即下一个儿子
   a[lst].height = a[rt].sibHeight + 1; // 高度为后缀儿子最高者加1
   a[lst].size = a[rt].sibSize + 1; // 规模为后缀儿子总规模加1
   ```

2. 上一个节点为被移除节点的长兄节点

   ```c++
   a[lst].rc = a[rt].rc; // 连接到被移除节点的右子，即下一个弟弟
   a[lst].sibSize -= a[rt].size; // 兄节点后缀弟节点总规模减去被移除子树大小
   a[lst].sibHeight = a[rt].sibHeight;
   ```

此时可以先更新栈顶节点的内容， 然后弹出栈顶元素。再更新栈顶元素（此时栈顶元素为被移除节点的上一个节点）。不断重复操作，直至栈中元素全部弹出，更新完成。

```c++
int rt = stack[ptr--], lst;
while (ptr >= 0) {
    lst = stack[ptr--]; // pop last traverse before rt
    if (lst == a[rt].parent) { // rt is first child of lst
        a[lst].size = a[rt].size + a[rt].sibSize + 1;
        a[lst].height = max(a[rt].height, a[rt].sibHeight) + 1;
    } else { // rt is sibling of lst
        a[lst].sibSize = a[rt].size + a[rt].sibSize;
        a[lst].sibHeight = max(a[rt].height, a[rt].sibHeight);
    }
    rt = lst; // update rt
}
```

#### 1.4 插入子树

首先需要找到要插入的位置，同样地，需要将遍历到的节点入栈。主体部分与移除子树类似，先更新栈顶节点的内容， 然后弹出栈顶元素。再更新栈顶元素（此时栈顶元素为被移除节点的上一个节点）。不断重复操作，直至栈中元素全部弹出，更新完成。

#### 1.5 复杂度分析

建树需时 $O(n)$ ，对于每一次查询操作（操作编号 `1` , `2` ）的时间复杂度仅为 $O(1)$ ，每次移动子树的需时则与路径长度相关，为 $O(cost)$ ，由于 $n$ 和 $cost$ 都是 $10^6$ 量级的，故算法的复时间杂度足以通过本题。

储存 $n$ 个节点需要 $O(n)$ 的空间，而栈需要存储最多 $n$ 个节点，同样需要 $O(n)$ 的空间，因此算法整体空间复杂度为 $O(n)$ 。

### 2  遇到的问题

#### 2.1 超时

最开始的时候，我在每次更新节点及其祖先的高度时会遍历该节点下所有子结点。尽管对于任意一点，祖先节点的规模是 $O(\log n)$ 的，但这些结点的子节点却比这些结点本身的数量多得多，因此需要找到一种方法，在更新节点时可以用 $O(1)$ 时间来更新高度，为此只需要在所有结点中储存后缀弟结点的高度最大值，并在每一次更新时更改。

#### 2.2 遍历方式

最初我使用了递归的方式遍历节点，但是在向上递归时预到了不少麻烦，例如单向存储的节点很难向上递归，故需要在节点记录上一个节点的信息，这对更新数据很不友好。因此改为栈存储节点记录，不仅解决了向上递归难的问题，同时减少了程序所需的内存空间。
