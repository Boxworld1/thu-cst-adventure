## 3-3 k-th  解题报告 ##

#### 容逸朗 2020010869 ####

### 1  解法 ###

题目要求找出从三个数组中组成数对的和值第 `k` 小的一对。一个直观的想法是利用小根堆，将所有可能值插入堆内，再进行 `k` 次 `pop` 操作就可以得到结果。

但是，所有可能的数对多达 $n^3=1.25 \times 10^{17}$ 组，全部插入堆内并不是一个可接受的做法。

#### 1.1 数组排序

为了化简问题，可以先把数组有序化，虽然题目没有给出同一数组的元素比较器，但我们可以把其他数组置为同一数值，例如比较数组 `a` 的元素时可以调用 `compare(i, 1, 1, j, 1, 1)` ，此时比较器会返回 `a[i]+b[1]+c[1]` 和  `a[j]+b[1]+c[1]` 的大小关系，左右消元后便可得到 `a[i]` 和 `a[j]` 的大小关系，利用快速排序就可以得到有序的数组。

一个简单的比较器实现如下：

```c++
int cmpA(const void *v1, const void *v2) {
    const int *n1 = (int*) v1;
    const int *n2 = (int*) v2;
    if (compare(*n1, 1, 1, *n2, 1, 1)) return -1;
    return 1;
}
```

#### 1.2 插入元素

下记 $(i,j,k)$ 为三个数组排序后数组 `a` 的第 `i` 个数，数组 `b` 的第 `j` 个数，数组 `c` 的第 `k` 个数组成的数对。

数组排序后，全局最小和值必为三个数组的首元素之和，即 $(1,1,1)$ 为全局最小和，那么有可能为次小值的数对共有 3 个： $(2,1,1),(1,2,1),(1,1,2)$ 。同理，当 $(i,j,k)$  为堆内最小值时，有可能为次小值的数对同样也有 3 个： $(i+1,j,k),(i,j+1,k),(i,j,k+1)$ 。

不断重复此操作 `k` 次便可以得到答案。但是这样做会导致堆内出现相同的数对（如：$(1,2,2)$ 可能被 $(1,1,2)$ 和 $(1,2,1)$ 加入到堆中 ），要解决这个问题可以规定一个插入的优先级，例如 $(i,j,k)$ 只能被 $(i-1,j,k)$ 加入到堆中，除非 $i=1$ ，此时 $(1,j,k)$ 则优先被 $(1,j-1,k)$  加入到堆中，若 $j=1$ ，则 $(1,1,k)$ 优先被 $(1,1,k-1)$ 加入到堆中，直至 $k=1$ ，讨论结束。

下面讨论此方法的正确性，对于 $(i,j,k),i>1$ ， 必定有 $(i-1,j,k)<(i,j,k)$ ，故当前者不是当前最小值时，后者必然不为当前最小值，故 $(i,j,k)$ 是否在堆内并不会影响算法的正确性。（同理，当 $i=1,j>1$ 和 $i=j=1,k>1$ 时也能保持其正确性）

#### 1.3 复杂度分析

对于第一部分，排序算法复杂度 $O(n\log n)$ ，储存数组元素需要 $O(n)$ 的空间。

对于第二部分，除了 $(1,1,1)$ 外，其余情况最坏情况下每次操作只会加入两个数对，因此任意时刻内，堆中元素规模可以保证在 $O(k)$ 以内，在紧邻储存的方式下堆只需要 $O(k)$ 的空间。

此时删除堆顶需时 $O(\log k)$ ，插入元素需时 $O(\log k)$ ，故每次操作耗时 $O(\log k)$ ，由于得到答案需要 $k$ 次操作，故第二部分的总复杂度为 $O(k\log k)$ 。

由此可知，算法时间复杂度为 $O(nlogn+klogk)$ ，空间复杂度为 $O(n+k)$ 。



