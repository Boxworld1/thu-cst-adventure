## LAB1 Zuma  解题报告 ##

#### 容逸朗 2020010869 ####

### 01.cpp   ###

最严重错误：Runtime Error

原因：在每一次消去珠子后，程序会对已消去珠子的左侧珠子作判定，但若已消去的珠子已经在最左侧，则此时调用 $a.at(-1)$ 会出现越界错误。

思路：构造一个最左侧珠子被消去的情况，如在字串 $AA$ 中任意位置插入 $A$ 。

### 02.cpp   ###

最严重错误：Runtime Error

原因：消去珠子后，若字串为空，此時调用 $a.at(0)$ 会出现越界错误。

思路：构造一个珠子被全部消去的情况，如在字串 $AA$ 中任意位置插入 $A$ 。

### 03.cpp   ###

最严重错误：Time Limited Exceeded

原因：string 的 insert() 函数是线性复杂度的，当数据规模很大时多次调用 insert() 会影响程序的效率。

思路：构造一个 $n=500000, m=500000$ 的样例，且过程中不会消去任何珠子。

### 04.cpp   ###

最严重错误：Wrong Answer

原因：消去珠子有误，判断左方同色珠子时位置多减了一位，导致珠子不足三颗时也能成功消去。

思路：在非最左侧且左方珠子不同色的珠子的左方插入同色珠子即可。如字串 $AAB$ ，在 $B$ 左侧插入 $B$ ，则程序消去 $ABB$ 为错误。

### 05.cpp   ###

最严重错误：Wrong Answer

原因：没有考虑 $n=0$ （空字串）的读入情况。

思路：构造一个首行为空字串的测例即可。

### 06.cpp   ###

最严重错误：Wrong Answer

原因：分块过长时没有重新分块，使分块有可能超出原先所佔有的空间，导致下一块的内容被复盖，从而出错。

思路：在首位插入 $4096+1＝4097$ （比最大容量大）颗珠子，让第一分块的珠子超出第一块所佔有的空间，此时第二分块的资料被复盖，程序出错。

相应测例：（初始字串为 $AB(BAAB)^{1023}BA$）

```
ABBAABB...AABBA
4097
0 C
0 D
0 D
0 C
...（重复1024次）
0 C
```

标准答案：（答案为 $C(DDCC)^{1024}AB(BAAB)^{1023}BA$ ）

```
CDDCC...DDCCABBAABB...AABBA
```

### 07.cpp   ###

最严重错误：Wrong Answer

原因：向左寻找可消去珠子时没有考虑到前面多个块中珠子为0的情况，导致应消珠子没有消去。

问题所在代码片段：

```c++
// 计算需要消除的开区间 (l, r)
    ...
    while (1) {
        while (l.first >= 0 && get(l) == ch) {
            l.second--;
            dis++;
            if (l.second < 0 && l.first >= 0) { // 此处应用 while
                l.first--;
                if (l.first >= 0)
                    l.second += plen[l.first];
            }
        }
        ...
    }
```

思路：构造一个至少三分块的珠串（$n > 4096$），消去第二分块的所有珠子，然后第一分块与第三分块可以连消。

相应测例：（初始字串为 $(EEFF)^{512}(CCDD)^{512}EEF$ ）

```
EEFFEE...EEFFCCDDCC...CCDDEEF
3
3072 D
2048 D
2050 E
```

标准答案：（答案为 $(EEFF)^{511}EE$ ）

```
EEFFEE...EE
```

解释：

```
以下"｜"表示分块边界。
经过"3072 D"操作后，程序中珠串变为EEFFEE...EEFF｜DD｜EEF，每个分块珠子颗数为：2048, 2, 3。
经过"2048 D"操作后，程序中珠串变为EEFFEE...EEFF｜｜EEF，每个分块珠子颗数为：2048, 0, 3。
经过"2050 E"操作后，程序中珠串变为EEFFEE...EEFF｜｜F，每个分块珠子颗数为：2048, 0, 1。
注意此操作中最后三颗珠子可以消去，但程序未消去，故出现错误。
```

### 08.cpp   ###

最严重错误：Wrong Answer

原因：没有考虑连消。

思路：构造有连消的测例。

### 09.cpp   ###

最严重错误：Runtime Error

原因：执行消除时若 $l.first$ 与 $r.first$ 相等，会导致分块长度变为很大的数（约为 $1.8e^{19}$，这是由于 $l.second + 1 - r.second < 0$ 以及  $plen$ 的类是无符号整形），此时进行 $memcpy()$ 操作)会导致段错误。

问题所在代码片段：

```c++
// 执行消除
    if (eliminated > 0) {
        ...
        if (l.first >= 0) {
            plen[l.first] = l.second + 1;
        }
        if (r.first < pn) {
            int len = plen[r.first] - r.second;
            if (len > 0) {
                memmove(&p[r.first][0], &p[r.first][r.second], len);
            }
            plen[r.first] = len;
        } // 当 l.first 与 r.first 相等时会导致分块长度变为一个很大的数
        ...
    }
```

思路：构造一个至少两分块的珠串（$n > 2048$），在单一块内消去珠子且该板块有剩余的珠子。

相应测例：（初始字串为 $A(CCDD)^{511}CCBA$）

```
ACCDDCC...DDCCBA
1
1024 D
```

标准答案：

```
ABA
```

### 10.cpp   ###

最严重错误：Wrong Answer

原因：执行消除时会消去 $l.first$ 的所有珠子，但 $l.first$ 的珠子不一定都在消除范围内。

问题所在代码片段：

```C++
// 执行消除
    if (eliminated > 0) {
        ...
        if (l.first == r.first) {
            ...
        } else {
            ...
            for (int i = l.first; i < r.first; i++) // 应为 l.first + 1
                plen[i] = 0;
        }
    }
```

思路：构造一个至少两分块的珠串（$n > 2048$），消去珠子时需要橫跨两个板块且第一个板块有剩余的珠子。

相应测例：（初始字串为 $A(CCDD)^{512}CCA$）

```
ACCDDCC...DDCCA
1
1026 C
```

标准答案：

```
AA
```

解释：

```
以下"｜"表示分块边界。
经过"1026 C"操作后，珠串变为A|A。
但程序把第一块的长度置为0，由于pn为2，故puts(a)会输出第一分块的首两个字符，即AC，故错误。
```

