## 2-6 Hacker  解题报告 ##

#### 容逸朗 2020010869 ####

### 1  解法 ###

本题是一道模拟题，题目要求将密文解码为给定的明文。一个简单的方法是利用散列表，以密文（`crc32` 值）为 `key` 、明文为 `value` 来存储。这样每次查询时可以用 $O(1)$ 的时间找到对应的明文或返回找不到值的信息。

#### 1.1 散列表实现

为了降低代码实现难度，这里使用了模数散列表，模数为 `N = 1000100` 。

需要特別注意的是，采用模数法的散列表对于 `key = 0` 是无法处理的（因为空位置的 `key` 值也为 `0`），不过由于 `crc32` 是返回值是大于 `0` 的，所以可以使用模数法的散列表。为了避免 `key` 为 `0` 時误认 `hashTable[0]` 为所求位置，可以用其他 `key` 值填入该位置中。

同时使用链表法处理冲突，对于任意任置 `x` ，若 `x` 中已有其他（非目标）`key` 值，则沿着 `(x + C) % N` 继续查找（此处 `C` 取 `9999991` 为素数，保证空间利用最大化），直至找到空位置或相同的 `key` 为止：

1. 若找到空位置，则插入 `key` 值。

   ```c++
   if (hashTable[x].key == 0) { // no data in x, then save value in x
       hashTable[x].key = tar;
       hashTable[x].value = val;
   		return;
   }
   ```

2. 否则，当找到相同的 `key` 值时，则判断 `value` 是否待插入的明文。

   - 若不是，则代表有多个明文匹配值为 `key` 的密文，此时将值设为 `0` （表示 `Duplicate`）
   - 若是，则代表散列表中已有这组数据，不需要再次储存。

```c++
if (hashTable[x].key == tar) { // key matches
    if (hashTable[x].value != val) hashTable[x].value = 0;
    return;
}
```

#### 1.2 查找密文

和 `1.1` 类似，沿链表查找 `key` 值，若找到空位置则返回 `-1` （表示找不到），否则在 `x` 处找到 `key` 值的话直接返回 `x` 即可。

```c++
int hash(ui idx, ui val) {
    int x = idx % N; // possible position
    if (hashTable[x].key == val) return x; // find target, return x
    if (hashTable[x].key == 0) return -1; // can't find target, return -1
    return hash(x + C, val); 
}
```

不妨假设待破解密文为 `var` ，使用上边的 `hash` 函数返回值为 `hashKey` 。那么当 `var = 0` 或 `hashKey <= 0` 时可以直接输出找不到明文（前者的原因是 `crc32` 的返回值大于 `0` ，后者 `hashKey = 0` 的位置被占用，`-1` 则表示找不到）。若幸运地找到 `hashKey` ，则需要判断其 `value` 是否为 `0` （`1.1` 中约定 `0` 代表对应明文有多个，直接输出 `Duplicate`），若不为 `0` ，则把 `value` 转换为字符串输出并把新明文加入散列表中。

每次查询的时间复杂度为 $O(1)$ ，故整体时间复杂度为 $O(n)$ 。

#### 1.3 数据存储

为了节省空间，加快查找速度，我们可以将明文（字符表中有 `18` 个字符，长度不大于 `8` ，最大值 $19^8 = 16983563041 < 2^{63}$）存放于 `long long` 而不是 `string` 。

由于密文是由 `crc32` 生成的，其值不会超过 `unsigned int` 能表示的最大范围，故使用 `unsigned int` 表示之。

#### 1.4 空间分析

首先可以把 `1` 至 `5` 位的明文加上盐的 `crc32` 值插入散列表中，这些值共有 $18^1+18^2+18^3+18^4+18^5 = 2000718$ 个。

待查询的密文最多有 `1000000` 条，最坏情况下每次查询都能得到新的明文。题目规定每次新加入的明文长度为 `1` 至 `8` 位之间，需要特別留意的是 `1` 至 `5` 位的明文已经全部插入散列表了，所以只需要把 `6` 至 `8` 位的散列表加入散列表便可，由此可知新增加的明文不超过 $3\times1000000=3000000$ 条。

因此散列表要有 `5001000` 以上的储存空间，为了避免数组太小造成查询时冲突过多，一个合适的散列表大小是 `10000000` ，又因为每个散列表需要存放一个 `key` 和一个 `value` （分別以 `unsigned int` 和 `long long` 存储），合计使用了 $(4+8)*10^7=120 MB$ 的内存空间。

### 2  其他事项

#### 2.1 超时的原因

一开始的时候我的程序是 `TLE` 的，这让我百思不得其解，但是仔细读题以后可以发现每次添加新明文时不需要理会长度为 `1` 至 `5` 位的字符串，改变此处可使程序的运行时间大幅降低。

#### 2.2 字符串拼接

由于计算 `crc32` 时需要加盐，因此需要进行字符串拼接操作，但 `crc32` 是流型函数，故可以把前者的 `crc32` 值计算出来再与盐一起算出最终的 `crc32` 值。从这里我得到了启发，在初始化散列表（插入 `1` 至 `5` 位明文时）可以按位操作，把前者的 `crc32` 值传给下一位计算，然后再加盐运算可以避免字符串拼接的问题。

```c++
inline ui cChar(int crc, char *buf) {
    return crc32(crc, (uc*)buf, 1);
}
inline ui cSalt(int crc) {
  	return crc32(crc, salt, saltLen);
}
```

前者用于计算已知 `crc32` 的值和一个字符时的 `crc32` 值，后者将 `crc32` 值加盐处理。
