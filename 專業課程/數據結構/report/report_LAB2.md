## LAB2 HashFun  实验报告 ##

#### 容逸朗 2020010869 ####

### 1  哈希实现

对于字符串的任意字符 `i` ，哈希操作如下：

1. ascii 字符串：可以使用多项式哈希，为简化计算，采用下面的策略近似计算 `32` 位哈希值。（多余数位溢出）
   $$
   hash(i)=((hash(i-1)<<5)|(hash(i-1)>>27))+str[i]\\
   hash(0)=0
   $$

2. utf-8 字符串：采用类似 MAD 的哈希方法，把加法改为了异或操作使每一个数据对哈希影响更充分。（初值素数任取）
   $$
   hash(i)=(hash(i-1)*33) \oplus str[i]\\
   hash(0)=5381
   $$

3. 双向平方试探：

   ```c++
   void double_square::init(){
   		count = 0; flag = -1; flag1 = 1; // 偏移步长，试探方向、冲突标记
   }
   int double_square::operator()(/* input */) {
   		if (flag1) { // 首次出现冲突
           tar_pos = last_choice; // 记录当前位置
           flag1 = 0; 
       }
   
       if (flag == -1) count++; // 左右两边均已历遍，偏移步长加1
       flag *= -1; // 改变试探方向
   
       int tmp = (count * count) % table_size; // 偏移量
       return (tar_pos + tmp * flag + table_size) % table_size; // 实际位置
   }
   ```

4. 公共溢出区：

   先更改 `hashtable` 的构造函数为下：

   ```C++
   hashtable(/* input */) {
   		Table = new hash_entry[table_size]; // 申请空间不变
       if (typeid(*my_collision) == typeid(buffer_overflow)) {
         	table_size = (size / 8) * 4 + 3; // 若为公共溢出区策略，保留部分空间予哈希表使用
       }
   }
   ```

   具体实现：

   ```c++
   void buffer_overflow::init(){
   		buffer_pos = 0; flag = 1; // 溢出区起点，首次冲突标记
   }
   int buffer_overflow::operator()(/* input */) {
       if (flag) { // 首次出现冲突
           flag = 0;
           buffer_pos = table_size; // 溢出区在哈希表之后
           return buffer_pos; // 返回溢出区首位
       }
       return last_choice + 1; // 线性查找下一位置
   }
   ```

### 2  测试数据

分別记 $I,Q$ 为插入与询问操作次数，$P$ 为每次操作冲突比例，$M=0$表示插入和查询乱序，$M=1$ 为先插入后查询。

对于所有测试数据，通过以下方法决定插入的数据：

1. 随机生成一个下标，然后在数据库出取出对应字符串。
2. 放入哈希函数中，若生成的数值尚未出现过，跳到操作 $4$。
3. 若重复次数少于 $20$ 次，回到操作 $1$ ，否则跳到操作 $4$。
4. 集合加入此数值并输出此操作。

数据特征如下所述：

|       | $I$      | $Q$       | $P$     | $M$  | 数据库 |
| ----- | :------- | :-------- | :------ | :--- | :----- |
| **1** | $20000$  | $15000$   | $6.41$  | $0$  | uoj    |
| **2** | $250000$ | $500000$  | $49.18$ | $1$  | uoj    |
| **3** | $450000$ | $300000$  | $67.18$ | $0$  | uoj    |
| **4** | $50000$  | $50000$   | $15.91$ | $1$  | hdu    |
| **5** | $300000$ | $300000$  | $55.29$ | $1$  | hdu    |
| **6** | $600000$ | $1000000$ | $73.74$ | $0$  | hdu    |

### 3  结果分析

1. 从结果 `4`  , `5` , `6` 知，将 utf-8 字符串当作 ascii 处理时的效率与针对 utf-8 设计的哈希效率相若。原因在于 utf-8 是基于 ascii 设计的编码，除 ascii 码外，utf-8 中每一个字节的码元只会是 `0x80` 至 `0xFF` ，不会与 ascii 码冲突。
2. 从结果 `1` , `4` 的 `Naive-linear` 与 `Naive-square` 两行中可以看出双向平方试探在数据冲突较集中的情况下的效率远高于线性试探，但正常情况（如结果 `5` , `6` ）下两者效能相若，原因在于他们最坏情况下都需要遍历整个哈希表。
3. 封闭散列的效率较开放散列高。从结果 `1` 知，当数据冲突较少时使用开放散列（公共溢出区）策略与封闭散列的效果相若。
4. 可能造成哈希表分布不均勻，导致哈希表性能降低。
5. 给定一个字典（字母数量有限）查找字符串对应数字时可以使用 Trie 树，插入查找操作的速度都与字串长度相关，为 $O(m)$ 。

