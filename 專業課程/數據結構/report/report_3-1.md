## 3-1 Circuit  解题报告 ##

#### 容逸朗 2020010869 ####

### 1  解法 ###

题目大意：给定一个数组，求数组内使元素 `i` 与前后 `k` 个数异或值最大的元素的下标。

#### 1.1 暴力解

对于任意数值，直接枚举区间内所有元素。

由于每一个元件都可以表示为一个 64 位无符号整数，因此每次比较需时 $O(1)$ ，需要比较 $2k$ 次，$n$ 个元件总共需要 $O(nk)$ 的时间，显然超时！

#### 1.2 贪心解

对于任意一个二进制数 $x$，与其等长且异或值最大的数必定与它的每一位都相反（例如： `0111` 与 `1000` ），这是由于相异的数的异或值为 `1` 。由此可以得到一个策略：逐位扫描 $x$ ，对于任意一位 $x[i]$ ，可以在区间内查找与 $x$ 在此位置上数值相异的数 $\neg x[i]$，若存在这样的数，则删去与 $x$ 在此位置上数值相等的元素。不断重复以上操作，直至得到唯一元素，若重复 64 次（遍历了 $x$ 的所有数位）后区间内仍有多个元素，则返回最小且不为 $x$ 的下标。

##### 1.2.1 实现

为了实现这一目标，我们可以利用 trie 树，若查找的数为 `0` ，则寻找左子树（若存在，否则向右查找），反之寻找右子树（若存在，否则向左寻找），由于不存在长度小于 $64$ 的路径（每条路径必定对应至少一个元件），故每次查找操作总能保证最终会到达叶节点。

除此之外，我们还需要维护可查找的区间。为此，只需保证查找操作前（后）加入（刚好符合区间）的元件并删除不在区间的元件。

##### 1.2.2 进一步实现

注意到有可能出现一样的元件，因此需要利用链表来记录不同编号的元件。一种简单的想法是，每次都把新元表添加到链表尾部，每次插入链表操作需时 $O(1)$ ，但查找操作却可能需时 $O(n)$ 。为此，一种更好的思路是保存叶节点在区间内的最小下标和最大下标。插入元件时从链表尾部加入，查找时从前往后搜寻，若不在区间内则将链表首节点向后移动，直至得到结果。

删除元件时，首先向下查找此元件，然后向上回溯，判断经过的路径（及节点）是否被其他元件共用，若有共用者则不予删除，删除完成。

插入元件则更为简便，只需要找到对应的节点，然后更新链表即可。

##### 1.2.3 复杂度分析

每次插入、删除和查找操作需时 $T(n)=64$ ，每种操作最多出现 $n$ 次，总时间复杂度为 $O(n)$ 。

空间复杂度虽然为 $O(n)$ 。 但常系数在此却不应忽略，原因在于 $512MB=2^{29}bytes$ ，而每一个叶节点若需储存 4 个（或更多）的参数，至少需要 $64\times 500000\times 4\times 4>2^{28}bytes$  ，导致 MLE。为此算法仍需要改进空间上的消耗。

#### 1.3 再改进

为了让节点只需要保存 3 个参数（左子、右子和对应元件），可以进一步思考如何在不保存父节点（用于移除元件）和链表末元素的情况下完成程序。

##### 1.3.1 移除

注意到移除节点并不需要从下而上回溯。每次移除时只需要记录最后一个同时具有左右节点的节点，然后直接从此处移除子树便可以达到效果。

##### 1.3.2 链表

每次查找操作都需要寻找下标最小的元件，但插入操作却是从后加入链表的。为此，我们只需要更改查找方向，从后而前插入及查找，那么可以保证节点的对应元件就是下标最小的元件。此时链表则用于保存此元件的下一个合法元件，被免出现节点对应元件就是要查找的元件自身的情况。

最后加入一个数组保存每次查找的结果，最后反向输出便可。





















